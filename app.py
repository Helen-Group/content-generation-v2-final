import gradio as gr
import os
from openai import OpenAI, AsyncOpenAI
from src.utils.ConfigLoader import ConfigLoader
from src.script_generation.GPT import GPT
from src.async_manager.DALLE.DALLE import DALLE
from src.async_manager.TTS.TTS import TTS  
from src.async_manager.async_manager import AsyncClient

from src.movie_production.movie import Movie

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv()) # read local .env file

DEBUG = False

MAXIMUM_SCENES = 40
OPENAI_CLIENT = OpenAI()
OPENAI_ASYNC_CLIENT = AsyncOpenAI(max_retries=1)
CONFIG_LOADER = ConfigLoader()
GPT_CLIENT = GPT(OPENAI_CLIENT)
DALLE_CLIENT = DALLE(OPENAI_CLIENT, OPENAI_ASYNC_CLIENT)
TTS_CLIENT = TTS()

def generate_script(user, system):
    """
    From two string variables `user` and `system`, generate scripts in the form of scenes.
    The correct formatting of the output should be:
    [
        {
            "dalle_prompt": f"{user} An evil potato",
            "text" : "Blah Blah Blah",
            "transformation_type" : pan_right_to_left
        },
        {
            "dalle_prompt": f"{user} An evil potato",
            "text" : "Blah Blah Blah",
            "transformation_type" : pan_right_to_left
        },
        ...
        title: Title here
    ]
    """

    # Define default config map
    config = {
        "GPT" : {
            "gpt_model" : "gpt-4",
            "temperature" : 0,
            "output_prefix" : "config"            
        },
        "global_settings" : {
            "output_path": "movie_workspace/"
        }
    }

    config["GPT"]["user"] = user
    config["GPT"]["system"] = system

    # Generate script and save to autogenerated named file
    if DEBUG:
        script = GPT_CLIENT.dummy_generate(config)
    else:
        script = GPT_CLIENT.generate(config)
    save_path = os.path.join(script["title"], "config.yaml")

    script = GPT_CLIENT.save_yaml(save_path, config, script)

    return script

def set_script_components(results=None):
    """
    Set components for preview
    """
    if not results:
        title = gr.Textbox(label = "Title", lines=0, visible=False)
        components = []
        for _ in range(0, MAXIMUM_SCENES):
            with gr.Column():
                dalle_prompt = gr.Textbox(label = "Dalle Prompt", lines=0, visible=False)
                text = gr.Textbox(label = "Text", lines=0, visible=False)
                transformation = gr.Textbox(label = "Transformation", lines=0, visible=False)
                components.append(dalle_prompt)
                components.append(text)
                components.append(transformation)
        components.append(title)
        return components
    else: 
        components = []
        number_of_scenes = len(results["scenes"])
        title = gr.Textbox(results["title"], label = f"Title", lines=2, visible=True, interactive=True)
        for i in range(0, number_of_scenes):
            dalle_prompt = gr.Textbox(results["scenes"][i]["prompt"], label = f"Dalle Prompt {i+1}", lines=2, visible=True, interactive=True)
            text = gr.Textbox(results["scenes"][i]["sentence"], label = f"Text {i+1}", lines=2, visible=True, interactive=True)
            transformation = gr.Textbox(results["scenes"][i]["transformation_type"], label = "Transformation", lines=1, visible=True, interactive=True)
            components.append(dalle_prompt)
            components.append(text)
            components.append(transformation)
        for i in range(number_of_scenes, MAXIMUM_SCENES):
            dalle_prompt = gr.Textbox(label = "Dalle Prompt", lines=0, visible=False)
            text = gr.Textbox(label = "Text", lines=0, visible=False)
            transformation = gr.Textbox(label = "Transformation", lines=0, visible=False)
            components.append(dalle_prompt)
            components.append(text)
            components.append(transformation)
        components.append(title)
        return components

def click_generate_script(user, system):
    """Wrapper for generating script and showing preview
    """
    results_dict = generate_script(user, system)
    return set_script_components(results_dict)


def serialize_script_components_into_args(script_components):
    """
    From input of components [TextBoxComponent<dalle_prompt>, TextBoxComponent<text>TextBoxComponent<dalle_prompt>,...],
    Return array of form:
    [
        {
            "prompt" : "safasd",
            "sentence" : "asdfad"
        },
        {
            "dalle_prompt" : "sad",
            "sentence" : "das"
        },
        ...
    ]
    """
    title = script_components[-1]
    script_args_list = []
    for i in range(0, len(script_components) - 1, 3):
        dalle_prompt = script_components[i]
        text = script_components[i + 1]
        transformation_type = script_components[i + 2]
        if (dalle_prompt == '' or text == ''):
            break
        script_args_list.append({
            "prompt" : dalle_prompt,
            "sentence" : text,
            "transformation_type" : transformation_type
        })

    return title, script_args_list

def generate_ingredients(script_args_list, title):
    """
    From input array of form:
    [
        {
            "prompt" : "safasd",
            "sentence" : "asdfad"
        },
        {
            "prompt" : "sad",
            "sentence" : "das"
        },
        ...
    ],
    Return output array representing ingredients for each scene of form:
    [
        {
            "image_file" : "/app/tests/movie_production/i-1.png", # required
            "audio_file" : "/app/tests/movie_production/a-1.mp3", # recommended
            "sentence" : "Zoom in, no cap",
            "transformation_type" : "zoom_in",
        },
        {
            "image_file" : "/app/tests/movie_production/i-2.png", # required
            "audio_file" : "/app/tests/movie_production/a-2.mp3", # recommended
            "sentence" : "Zoom out, bruhhh",
            "transformation_type" : "zoom_out",
        },
        ...
    ],
    """
    config = {
        "DALLE" : {
            "dalle_model" : "dall-e-3",
            "quality" : "standard",
            "output_prefix" : "i"
        },
        "TTS" : {
            "voice" : "oH7WLysPgrahlQ0DFWUT",
            "output_prefix" : "a"
        },
        "global_settings" : {
            "output_path": f"movie_workspace/{title}"
        }
    }

    output_config = {
        "scenes" : script_args_list
    }

    async_client = AsyncClient(config, output_config, DALLE=DALLE_CLIENT, TTS=TTS_CLIENT)
    ingredients = async_client.run()

    return ingredients

def set_ingredients_components(results=None):
    """
    Result is of form [{"dalle_prompt"},{},...]
    Return maximum_scenes
    """

    if not results:
        components = []
        for _ in range(0, MAXIMUM_SCENES):
            with gr.Column():
                scene_image = gr.Image(label = "Scene Image", visible=False)
                scene_audio = gr.Audio (label = "Scene Audio", visible=False)
                scene_text = gr.Textbox(label = "Text", lines=0, visible=False)
                scene_animation_type = gr.Dropdown(["no_transform", "zoom_in", "zoom_out","pan_left_to_right","pan_right_to_left"], type="value", visible=False)
                components.append(scene_image)
                components.append(scene_audio)
                components.append(scene_text)
                components.append(scene_animation_type)

        return components
    else: 
        components = []
        results_len = len(results)
        for i in range(0, results_len):
            scene_image = gr.Image(results[i]["image_file"], label = "Scene Image", visible=True, interactive=True,type='filepath')
            scene_audio = gr.Audio (results[i]["audio_file"], label = "Scene Audio", visible=True, interactive=True, type='filepath')
            scene_text = gr.Textbox(results[i]["sentence"], label = "Text", lines=0, visible=True, interactive=True)
            scene_animation_type = gr.Dropdown(choices=["no_transform", "zoom_in", "zoom_out","pan_left_to_right","pan_right_to_left"], value=results[i]["transformation_type"], type="value", visible=True, interactive=True)
            components.append(scene_image)
            components.append(scene_audio)
            components.append(scene_text)
            components.append(scene_animation_type)
        for i in range(results_len, MAXIMUM_SCENES):
            scene_image = gr.Image(label = "Scene Image", visible=False, type='filepath')
            scene_audio = gr.Audio (label = "Scene Audio", visible=False, type='filepath')
            scene_text = gr.Textbox(label = "Text", lines=0, visible=False)
            scene_animation_type = gr.Dropdown(["no_transform", "zoom_in", "zoom_out","pan_left_to_right","pan_right_to_left"], type="value", visible=False)
            components.append(scene_image)
            components.append(scene_audio)
            components.append(scene_text)
            components.append(scene_animation_type)
        return components

def click_generate_ingredients(*components):
    title, script_args_list = serialize_script_components_into_args(components)
    results = generate_ingredients(script_args_list, title)
    return set_ingredients_components(results)

def serialize_ingredients_components_into_args(ingredients_components):
    """
    From input of components [ImageComponent<image>, AudioComponent<audio>,...],
    Return dict of form:
    {
        "background_audio_file"
        "scenes":
            [
                {
                    "image_file" : "safasd",
                    "audio_file" : "asdfad",
                    "text" : "safasd",
                    "animation_type" : "asdfad"
                },
                {
                    "image_file" : "fdsf",
                    "audio_file" : "sdffd",
                    "text" : "jdgh",
                    "animation_type" : "ewrwfd"
                },
                ...
            ]
        }
    Also return output filepath:
    /app/movie_workspace/...
    """
    ingredients_args = {
        "background_audio_file" : ingredients_components[0],
        "scenes" : []
    }
    output_file = ingredients_components[1]
    for i in range(2, len(ingredients_components), 4):
        image_file = ingredients_components[i]
        audio_file = ingredients_components[i + 1]
        text = ingredients_components[i + 2]
        animation_type = ingredients_components[i + 3]
        if (image_file == None or audio_file == None or text == '' or animation_type == ''):
            break
        ingredients_args["scenes"].append({
            "image_file" : image_file,
            "audio_file" : audio_file,
            "text" : text,
            "animation_type" : animation_type
        })
    
    return ingredients_args, output_file

def generate_video(ingredients_args, output_file):
    generated_movie = Movie(ingredients_args)
    return generated_movie.save_to_file(output_file)

def click_generate_video(*components):
    ingredients_args, output_file = serialize_ingredients_components_into_args(components)
    video_file_path = generate_video(ingredients_args, output_file)
    return gr.Video(video_file_path, label="Output Video", height="30vw")

with gr.Blocks() as demo:
    gr.Markdown("# Content Generation")

    #--- Script Generation ---
    gr.Markdown("## Prompt")
    user_text, system_text = GPT_CLIENT.get_templates()
    with gr.Row(equal_height=True):
        user = gr.Textbox(user_text, label = "User", lines=4)
        system = gr.Textbox(system_text, label = "System", lines=4)
       
    btn_generate_script = gr.Button("Generate Script")     
    #--- Script Preview ---
    gr.Markdown("## Preview Script")
    script_components = []
    with gr.Row(equal_height=True):
        script_components = set_script_components()
    btn_generate_script.click(fn=click_generate_script, inputs=[user, system], outputs=script_components)    
    
    # --- Ingredient Generation ---
    gr.Markdown("## Preview Ingredients")
    btn_pull_ingredients = gr.Button("Pull All Ingredients")
    scene_ingredients_components = []
    with gr.Row(equal_height=True):
        scene_ingredients_components = set_ingredients_components()
    btn_pull_ingredients.click(fn=click_generate_ingredients, inputs=script_components, outputs=scene_ingredients_components)

    gr.Markdown("## Add Background Music")
    with gr.Column():
        audio_filepath = gr.Audio(label = "Audio", type="filepath")
        output_filepath = gr.Textbox("/app/movie_workspace/movies/movie_1.mp4", label = "Output Filepath", lines=1, interactive=True)

    # --- Generate Video ---
    gr.Markdown("## Generated Video")
    btn_generate_video = gr.Button("Generate the video")
    with gr.Row():
        output_video = gr.Video(label="video", height="30vw")

    btn_generate_video.click(fn=click_generate_video, inputs=[audio_filepath, output_filepath, *scene_ingredients_components], outputs=output_video)



# Have to specify: cannot use 127.0.0.1 because this only takes in requests
# designated specifically for localhost; 0.0.0.0 accepts all network requests
# in the given port
demo.launch(server_name="0.0.0.0")
